/*
* generated by Xtext
*/
package xtraitj.ui.outline

import com.google.inject.Inject
import org.eclipse.jface.viewers.StyledString
import org.eclipse.xtext.common.types.JvmTypeReference
import org.eclipse.xtext.ui.IImageHelper
import org.eclipse.xtext.ui.editor.outline.impl.DefaultOutlineTreeProvider
import org.eclipse.xtext.ui.editor.outline.impl.DocumentRootNode
import org.eclipse.xtext.ui.editor.outline.impl.EObjectNode
import org.eclipse.xtext.xbase.validation.UIStrings
import org.eclipse.xtext.xtype.XtypePackage
import xtraitj.jvmmodel.XtraitjJvmModelHelper
import xtraitj.jvmmodel.XtraitjJvmModelUtil
import xtraitj.jvmmodel.XtraitjJvmOperation
import xtraitj.util.XtraitjAnnotatedElementHelper
import xtraitj.xtraitj.TJClass
import xtraitj.xtraitj.TJConstructor
import xtraitj.xtraitj.TJDeclaration
import xtraitj.xtraitj.TJField
import xtraitj.xtraitj.TJMember
import xtraitj.xtraitj.TJMethod
import xtraitj.xtraitj.TJProgram
import xtraitj.xtraitj.TJRequiredMethod
import xtraitj.xtraitj.TJTrait
import xtraitj.xtraitj.TJTraitReference
import xtraitj.xtraitj.XtraitjPackage
import org.eclipse.xtext.ui.editor.outline.impl.AbstractOutlineNode

/**
 * Customization of the default outline structure.
 *
 * see http://www.eclipse.org/Xtext/documentation.html#outline
 */
class XtraitjOutlineTreeProvider extends DefaultOutlineTreeProvider {
	
	@Inject IImageHelper images
	
	@Inject UIStrings uiStrings
	
	@Inject extension XtraitjJvmModelUtil
	@Inject extension XtraitjJvmModelHelper
	@Inject extension XtraitjAnnotatedElementHelper
	
	def _createChildren(DocumentRootNode parentNode, TJProgram p) {
		if (p.name != null) {
			// corresponds to package
			createEStructuralFeatureNode(
				parentNode,
				p,
				XtraitjPackage::eINSTANCE.TJProgram_Name, 
				images.getImage("package_obj.gif"),
				p.name, 
				true)
		}
		
		if (p.importSection != null && 
				!p.importSection.importDeclarations.empty) {
			createEStructuralFeatureNode(
				parentNode, 
				p.importSection,
				XtypePackage::eINSTANCE.XImportSection_ImportDeclarations,
				images.getImage("impc_obj.gif"),
				"import declarations",
				true)
		}
		
		for (content : p.elements) {
			createNode(parentNode, content);
		}
	}

	def _createChildren(EObjectNode parentNode, TJClass c) {
		val opsFromInterfaces = c.interfaces.getXtraitjJvmOperationsFromJavaInterfaces(c)
		
		nodesForTraitReferences(parentNode, c)
		nodesForRequirements(parentNode, c, opsFromInterfaces)
		nodesForProvides(parentNode, c)
		
		for (f : c.fields) {
			createNode(parentNode, f)
		}
		
		for (cons : c.constructors) {
			createNode(parentNode, cons)
		}
	}

	def _createChildren(EObjectNode parentNode, TJTrait t) {
		nodesForTraitReferences(parentNode, t)
		nodesForRequirements(parentNode, t)
		nodesForProvides(parentNode, t)
		
		for (m : t.members.filter(typeof(TJField))) {
			createNode(parentNode, m)
		}
		
		for (m : t.members.filter(typeof(TJRequiredMethod))) {
			createNode(parentNode, m)
		}
		
		for (m : t.members.filter(typeof(TJMethod))) {
			createNode(parentNode, m)
		}
	}

	def nodesForTraitReferences(EObjectNode parentNode, TJDeclaration d) {
		if (d.traitExpression != null) {
			for (ref : d.traitExpression.references) {
				createNode(parentNode, ref)	
			}
		}
	}

	def nodesForRequirements(EObjectNode parentNode, TJDeclaration d) {
		nodesForRequirements(parentNode, d, emptyList)
	}

	def nodesForRequirements(EObjectNode parentNode, TJDeclaration d, Iterable<XtraitjJvmOperation> interfaceMethods) {
		val associatedClass = d.associatedJavaClass
		val ops = associatedClass.getXtraitjResolvedOperationsFromSuperTypes(d)
		val fieldRequirements = ops.requiredFields
		val methodRequirements = ops.requiredMethods
		
		if (!fieldRequirements.empty || !methodRequirements.empty || !interfaceMethods.empty) {
			val reqNode = new XtraitjRequirementsNode(parentNode, images.getImage("externalize.gif"))
			nodesForRequirements(reqNode, interfaceMethods)
			nodesForRequirements(reqNode, fieldRequirements)
			nodesForRequirements(reqNode, methodRequirements)
		}
	}

	def nodesForProvides(EObjectNode parentNode, TJDeclaration d) {
		val associatedClass = d.associatedJavaClass
		val ops = associatedClass.xtraitjResolvedOperationsNotDeclared
		val provides = ops.definedMethods
		
		if (!provides.empty) {
			val reqNode = new XtraitjProvidesNode(parentNode, images.getImage("externalize.gif"))
			nodesForProvides(reqNode, provides)
		}
	}

	def nodesForRequirements(XtraitjRequirementsNode reqNode, Iterable<XtraitjJvmOperation> requirements) {
		for (req : requirements) {
			val jvmOp = req.op

			if (jvmOp.annotatedRequiredField) {
				reqNode.createEObjectNode(
					jvmOp,
					_image(jvmOp),
					jvmOp.simpleName.stripGetter +
					" : " + req.returnType.simpleName,
					true
				)
			} else {
				nodeForJvmOperation(reqNode, req)
			}
		}
	}
	
	private def nodeForJvmOperation(AbstractOutlineNode node, XtraitjJvmOperation req) {
		val jvmOp = req.op
		
		node.createEObjectNode(
			jvmOp,
			_image(jvmOp),
			new StyledString(
				jvmOp.simpleName 
				+ req.parametersTypes.parameterTypesToString
			).append(
				new StyledString(" : " + 
					req.returnType.simpleName,
					StyledString::DECORATIONS_STYLER
				)
			),
			true
		)
	}

	def private parameterTypesToString(Iterable<JvmTypeReference> parameterTypes) {
		"(" + parameterTypes.map[uiStrings.referenceToString(it, "[null]")].join(", ") + ")"
	}

	def nodesForProvides(XtraitjProvidesNode provNode, Iterable<XtraitjJvmOperation> provides) {
		for (req : provides) {
			nodeForJvmOperation(provNode, req)
		}
	}
	
	def _isLeaf(TJMember m) {
		return true;
	}

	def _isLeaf(TJConstructor m) {
		return true;
	}

	def _isLeaf(TJTraitReference r) {
		return true;
	}

}
