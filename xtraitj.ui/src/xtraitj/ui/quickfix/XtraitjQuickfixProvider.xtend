/*
* generated by Xtext
*/
package xtraitj.ui.quickfix

import com.google.inject.Inject
import org.eclipse.xtext.ui.editor.quickfix.DefaultQuickfixProvider
import org.eclipse.xtext.ui.editor.quickfix.Fix
import org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor
import org.eclipse.xtext.validation.Issue
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder
import xtraitj.validation.XtraitjValidator
import xtraitj.xtraitj.TJClass
import xtraitj.xtraitj.XtraitjFactory
import xtraitj.jvmmodel.XtraitjJvmModelUtil

import static extension xtraitj.jvmmodel.XtraitjResolvedOperationUtil.*
import static extension xtraitj.util.XtraitjModelUtil.*
import xtraitj.jvmmodel.XtraitjJvmModelHelper
import xtraitj.xtraitj.TJTraitReference

/**
 * Custom quickfixes.
 *
 * see http://www.eclipse.org/Xtext/documentation.html#quickfixes
 */
class XtraitjQuickfixProvider extends DefaultQuickfixProvider {
	
	@Inject extension JvmTypesBuilder
	@Inject extension XtraitjJvmModelUtil
	@Inject extension XtraitjJvmModelHelper

	@Fix(XtraitjValidator::MISSING_REQUIRED_FIELD)
	def addMissingRequiredField(Issue issue, IssueResolutionAcceptor acceptor) {
		val fieldName = issue.data.get(0).stripGetter
		val fieldType = issue.data.get(1)
		acceptor.accept(issue, 
			"Add required field '" + fieldType + " " + fieldName + "'", 
			"Add the missing required field '" + fieldType + " " + fieldName + "'", 
			'field_private_obj.gif') 
		[
			elem, context |
			// we need to access the actual required IResolvedOperation
			// to get the type of the required field as a correct
			// type reference: using only type string representation
			// would not allow to get a proper type reference in case
			// of type paramenters (e.g., List<String>)
			val traitRef = (elem as TJTraitReference)
			val clazz = traitRef.containingDeclaration as TJClass
			val associatedType = clazz.associatedJavaType
			val ops = traitRef.getTraitReferenceXtraitjResolvedOperations(associatedType)
			val fieldRequirements = ops.requiredFields
			clazz.fields += 
				XtraitjFactory.eINSTANCE.createTJField => [
					name = fieldName
					type = fieldRequirements.findFirst[
						simpleName.stripGetter == fieldName
					].returnType.cloneWithProxies
				]
		]
	}

//	@Fix(MyDslValidator::INVALID_NAME)
//	def capitalizeName(Issue issue, IssueResolutionAcceptor acceptor) {
//		acceptor.accept(issue, 'Capitalize name', 'Capitalize the name.', 'upcase.png') [
//			context |
//			val xtextDocument = context.xtextDocument
//			val firstLetter = xtextDocument.get(issue.offset, 1)
//			xtextDocument.replace(issue.offset, 1, firstLetter.toUpperCase)
//		]
//	}
}
