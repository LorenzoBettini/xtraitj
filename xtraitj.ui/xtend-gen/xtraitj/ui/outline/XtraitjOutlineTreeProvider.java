/**
 * generated by Xtext
 */
package xtraitj.ui.outline;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.inject.Inject;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.jface.viewers.StyledString;
import org.eclipse.swt.graphics.Image;
import org.eclipse.xtext.common.types.JvmOperation;
import org.eclipse.xtext.common.types.JvmTypeReference;
import org.eclipse.xtext.ui.IImageHelper;
import org.eclipse.xtext.ui.editor.outline.impl.DefaultOutlineTreeProvider;
import org.eclipse.xtext.ui.editor.outline.impl.DocumentRootNode;
import org.eclipse.xtext.ui.editor.outline.impl.EObjectNode;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.validation.UIStrings;
import org.eclipse.xtext.xtype.XImportDeclaration;
import org.eclipse.xtext.xtype.XImportSection;
import org.eclipse.xtext.xtype.XtypePackage;
import xtraitj.jvmmodel.TraitJJvmModelUtil;
import xtraitj.ui.outline.TraitJRequirementsNode;
import xtraitj.xtraitj.TJClass;
import xtraitj.xtraitj.TJDeclaration;
import xtraitj.xtraitj.TJField;
import xtraitj.xtraitj.TJMember;
import xtraitj.xtraitj.TJMethod;
import xtraitj.xtraitj.TJProgram;
import xtraitj.xtraitj.TJRequiredMethod;
import xtraitj.xtraitj.TJTrait;
import xtraitj.xtraitj.TJTraitExpression;
import xtraitj.xtraitj.TJTraitReference;
import xtraitj.xtraitj.XtraitjPackage;

/**
 * Customization of the default outline structure.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#outline
 */
@SuppressWarnings("all")
public class XtraitjOutlineTreeProvider extends DefaultOutlineTreeProvider {
  @Inject
  private IImageHelper images;
  
  @Inject
  private UIStrings uiStrings;
  
  @Inject
  @Extension
  private TraitJJvmModelUtil _traitJJvmModelUtil;
  
  public void _createChildren(final DocumentRootNode parentNode, final TJProgram p) {
    String _name = p.getName();
    boolean _notEquals = (!Objects.equal(_name, null));
    if (_notEquals) {
      EAttribute _tJProgram_Name = XtraitjPackage.eINSTANCE.getTJProgram_Name();
      Image _image = this.images.getImage("package_obj.gif");
      String _name_1 = p.getName();
      this.createEStructuralFeatureNode(parentNode, p, _tJProgram_Name, _image, _name_1, 
        true);
    }
    boolean _and = false;
    XImportSection _importSection = p.getImportSection();
    boolean _notEquals_1 = (!Objects.equal(_importSection, null));
    if (!_notEquals_1) {
      _and = false;
    } else {
      XImportSection _importSection_1 = p.getImportSection();
      EList<XImportDeclaration> _importDeclarations = _importSection_1.getImportDeclarations();
      boolean _isEmpty = _importDeclarations.isEmpty();
      boolean _not = (!_isEmpty);
      _and = (_notEquals_1 && _not);
    }
    if (_and) {
      XImportSection _importSection_2 = p.getImportSection();
      EReference _xImportSection_ImportDeclarations = XtypePackage.eINSTANCE.getXImportSection_ImportDeclarations();
      Image _image_1 = this.images.getImage("impc_obj.gif");
      this.createEStructuralFeatureNode(parentNode, _importSection_2, _xImportSection_ImportDeclarations, _image_1, 
        "import declarations", 
        true);
    }
    EList<TJDeclaration> _elements = p.getElements();
    for (final TJDeclaration content : _elements) {
      this.createNode(parentNode, content);
    }
  }
  
  public void _createChildren(final EObjectNode parentNode, final TJClass c) {
    this.nodesForTraitReferences(parentNode, c);
    Iterable<JvmOperation> _jvmAllInterfaceMethods = this._traitJJvmModelUtil.jvmAllInterfaceMethods(c);
    this.nodesForRequirements(parentNode, c, _jvmAllInterfaceMethods);
    EList<TJField> _fields = c.getFields();
    for (final TJField m : _fields) {
      this.createNode(parentNode, m);
    }
  }
  
  public void _createChildren(final EObjectNode parentNode, final TJTrait t) {
    this.nodesForTraitReferences(parentNode, t);
    this.nodesForRequirements(parentNode, t);
    EList<TJMember> _members = t.getMembers();
    Iterable<TJField> _filter = Iterables.<TJField>filter(_members, TJField.class);
    for (final TJField m : _filter) {
      this.createNode(parentNode, m);
    }
    EList<TJMember> _members_1 = t.getMembers();
    Iterable<TJRequiredMethod> _filter_1 = Iterables.<TJRequiredMethod>filter(_members_1, TJRequiredMethod.class);
    for (final TJRequiredMethod m_1 : _filter_1) {
      this.createNode(parentNode, m_1);
    }
    EList<TJMember> _members_2 = t.getMembers();
    Iterable<TJMethod> _filter_2 = Iterables.<TJMethod>filter(_members_2, TJMethod.class);
    for (final TJMethod m_2 : _filter_2) {
      this.createNode(parentNode, m_2);
    }
  }
  
  public void nodesForTraitReferences(final EObjectNode parentNode, final TJDeclaration d) {
    TJTraitExpression _traitExpression = d.getTraitExpression();
    boolean _notEquals = (!Objects.equal(_traitExpression, null));
    if (_notEquals) {
      TJTraitExpression _traitExpression_1 = d.getTraitExpression();
      EList<TJTraitReference> _references = _traitExpression_1.getReferences();
      for (final TJTraitReference ref : _references) {
        this.createNode(parentNode, ref);
      }
    }
  }
  
  public void nodesForRequirements(final EObjectNode parentNode, final TJDeclaration d) {
    List<JvmOperation> _emptyList = CollectionLiterals.<JvmOperation>emptyList();
    this.nodesForRequirements(parentNode, d, _emptyList);
  }
  
  public void nodesForRequirements(final EObjectNode parentNode, final TJDeclaration d, final Iterable<JvmOperation> interfaceMethods) {
    final Iterable<JvmOperation> fieldRequirements = this._traitJJvmModelUtil.jvmAllRequiredFieldOperations(d);
    final Iterable<JvmOperation> methodRequirements = this._traitJJvmModelUtil.jvmAllRequiredMethodOperationsFromReferences(d);
    boolean _or = false;
    boolean _or_1 = false;
    boolean _isEmpty = IterableExtensions.isEmpty(fieldRequirements);
    boolean _not = (!_isEmpty);
    if (_not) {
      _or_1 = true;
    } else {
      boolean _isEmpty_1 = IterableExtensions.isEmpty(methodRequirements);
      boolean _not_1 = (!_isEmpty_1);
      _or_1 = (_not || _not_1);
    }
    if (_or_1) {
      _or = true;
    } else {
      boolean _isEmpty_2 = IterableExtensions.isEmpty(interfaceMethods);
      boolean _not_2 = (!_isEmpty_2);
      _or = (_or_1 || _not_2);
    }
    if (_or) {
      Image _image = this.images.getImage("externalize.gif");
      TraitJRequirementsNode _traitJRequirementsNode = new TraitJRequirementsNode(parentNode, _image);
      final TraitJRequirementsNode reqNode = _traitJRequirementsNode;
      this.nodesForRequirements(reqNode, interfaceMethods);
      this.nodesForRequirements(reqNode, fieldRequirements);
      this.nodesForRequirements(reqNode, methodRequirements);
    }
  }
  
  public void nodesForRequirements(final TraitJRequirementsNode reqNode, final Iterable<JvmOperation> requirements) {
    for (final JvmOperation req : requirements) {
      {
        final TJMember source = this._traitJJvmModelUtil.originalSource(req);
        boolean _notEquals = (!Objects.equal(source, null));
        if (_notEquals) {
          if ((source instanceof TJField)) {
            Image __image = this._image(source);
            String _simpleName = req.getSimpleName();
            String _stripGetter = this._traitJJvmModelUtil.stripGetter(_simpleName);
            String _plus = (_stripGetter + 
              " : ");
            JvmTypeReference _type = source.getType();
            String _simpleName_1 = _type.getSimpleName();
            String _plus_1 = (_plus + _simpleName_1);
            this.createEObjectNode(reqNode, source, __image, _plus_1, 
              true);
          } else {
            Image __image_1 = this._image(source);
            String _simpleName_2 = req.getSimpleName();
            String _parameters = this.uiStrings.parameters(req);
            String _plus_2 = (_simpleName_2 + _parameters);
            StyledString _styledString = new StyledString(_plus_2);
            JvmTypeReference _type_1 = source.getType();
            String _simpleName_3 = _type_1.getSimpleName();
            String _plus_3 = (" : " + _simpleName_3);
            StyledString _styledString_1 = new StyledString(_plus_3, 
              StyledString.DECORATIONS_STYLER);
            StyledString _append = _styledString.append(_styledString_1);
            this.createEObjectNode(reqNode, source, __image_1, _append, 
              true);
          }
        } else {
          this.createNode(reqNode, req);
        }
      }
    }
  }
  
  public Object _text(final JvmOperation op) {
    Object _xblockexpression = null;
    {
      final TJMember source = this._traitJJvmModelUtil.originalSource(op);
      boolean _equals = Objects.equal(source, null);
      if (_equals) {
        super._text(op);
      }
      Object _xifexpression = null;
      if ((source instanceof TJField)) {
        String _simpleName = op.getSimpleName();
        String _stripGetter = this._traitJJvmModelUtil.stripGetter(_simpleName);
        String _plus = (_stripGetter + " : ");
        JvmTypeReference _returnType = op.getReturnType();
        String _simpleName_1 = _returnType.getSimpleName();
        String _plus_1 = (_plus + _simpleName_1);
        _xifexpression = _plus_1;
      } else {
        Object __text = super._text(op);
        _xifexpression = __text;
      }
      _xblockexpression = (_xifexpression);
    }
    return _xblockexpression;
  }
  
  public boolean _isLeaf(final TJMember m) {
    return true;
  }
  
  public boolean _isLeaf(final TJTraitReference r) {
    return true;
  }
  
  public boolean _isLeaf(final JvmOperation o) {
    return true;
  }
}
