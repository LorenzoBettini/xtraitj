/**
 * generated by Xtext
 */
package xtraitj.validation;

import com.google.common.base.Objects;
import com.google.inject.Inject;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtext.common.types.JvmMember;
import org.eclipse.xtext.common.types.JvmOperation;
import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.XExpression;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function0;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import xtraitj.jvmmodel.TraitJJvmModelUtil;
import xtraitj.util.TraitJModelUtil;
import xtraitj.validation.AbstractXtraitjValidator;
import xtraitj.xtraitj.TJAliasOperation;
import xtraitj.xtraitj.TJClass;
import xtraitj.xtraitj.TJDeclaration;
import xtraitj.xtraitj.TJField;
import xtraitj.xtraitj.TJHideOperation;
import xtraitj.xtraitj.TJMember;
import xtraitj.xtraitj.TJMethod;
import xtraitj.xtraitj.TJMethodDeclaration;
import xtraitj.xtraitj.TJProgram;
import xtraitj.xtraitj.TJRedirectOperation;
import xtraitj.xtraitj.TJRenameOperation;
import xtraitj.xtraitj.TJRequiredMethod;
import xtraitj.xtraitj.TJRestrictOperation;
import xtraitj.xtraitj.TJTrait;
import xtraitj.xtraitj.TJTraitExpression;
import xtraitj.xtraitj.TJTraitOperation;
import xtraitj.xtraitj.TJTraitReference;
import xtraitj.xtraitj.TjTraitOperationForProvided;
import xtraitj.xtraitj.XtraitjPackage;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class XtraitjValidator extends AbstractXtraitjValidator {
  public final static String PREFIX = "xtraitj.";
  
  public final static String DEPENDENCY_CYCLE = new Function0<String>() {
    public String apply() {
      String _plus = (XtraitjValidator.PREFIX + "DependencyCycle");
      return _plus;
    }
  }.apply();
  
  public final static String TRAIT_INITIALIZES_FIELD = new Function0<String>() {
    public String apply() {
      String _plus = (XtraitjValidator.PREFIX + "TraitInitializesField");
      return _plus;
    }
  }.apply();
  
  public final static String MISSING_REQUIRED_FIELD = new Function0<String>() {
    public String apply() {
      String _plus = (XtraitjValidator.PREFIX + "MissingRequiredField");
      return _plus;
    }
  }.apply();
  
  public final static String MISSING_REQUIRED_METHOD = new Function0<String>() {
    public String apply() {
      String _plus = (XtraitjValidator.PREFIX + "MissingRequiredMethod");
      return _plus;
    }
  }.apply();
  
  public final static String MISSING_INTERFACE_METHOD = new Function0<String>() {
    public String apply() {
      String _plus = (XtraitjValidator.PREFIX + "MissingInterfaceMethod");
      return _plus;
    }
  }.apply();
  
  public final static String HIDING_REQUIRED = new Function0<String>() {
    public String apply() {
      String _plus = (XtraitjValidator.PREFIX + "HidingRequired");
      return _plus;
    }
  }.apply();
  
  public final static String ALIASING_REQUIRED = new Function0<String>() {
    public String apply() {
      String _plus = (XtraitjValidator.PREFIX + "AliasingRequired");
      return _plus;
    }
  }.apply();
  
  public final static String RESTRICTING_REQUIRED = new Function0<String>() {
    public String apply() {
      String _plus = (XtraitjValidator.PREFIX + "RestrictingRequired");
      return _plus;
    }
  }.apply();
  
  public final static String FIELD_REDIRECTED_TO_METHOD = new Function0<String>() {
    public String apply() {
      String _plus = (XtraitjValidator.PREFIX + "FieldRedirectedToMethod");
      return _plus;
    }
  }.apply();
  
  public final static String METHOD_REDIRECTED_TO_FIELD = new Function0<String>() {
    public String apply() {
      String _plus = (XtraitjValidator.PREFIX + "MethodRedirectedToField");
      return _plus;
    }
  }.apply();
  
  public final static String REDIRECT_NOT_COMPLIANT = new Function0<String>() {
    public String apply() {
      String _plus = (XtraitjValidator.PREFIX + "RedirectNotCompliant");
      return _plus;
    }
  }.apply();
  
  public final static String REDIRECT_TO_SAME_MEMBER = new Function0<String>() {
    public String apply() {
      String _plus = (XtraitjValidator.PREFIX + "RedirectToSameMember");
      return _plus;
    }
  }.apply();
  
  public final static String NOT_AN_INTERFACE = new Function0<String>() {
    public String apply() {
      String _plus = (XtraitjValidator.PREFIX + "NotAnInterface");
      return _plus;
    }
  }.apply();
  
  public final static String DUPLICATE_TRAIT_REFERENCE = new Function0<String>() {
    public String apply() {
      String _plus = (XtraitjValidator.PREFIX + "DuplicateTraitReference");
      return _plus;
    }
  }.apply();
  
  public final static String DUPLICATE_MEMBER = new Function0<String>() {
    public String apply() {
      String _plus = (XtraitjValidator.PREFIX + "DuplicateMember");
      return _plus;
    }
  }.apply();
  
  public final static String DUPLICATE_DECLARATION = new Function0<String>() {
    public String apply() {
      String _plus = (XtraitjValidator.PREFIX + "DuplicateDeclaration");
      return _plus;
    }
  }.apply();
  
  public final static String FIELD_CONFLICT = new Function0<String>() {
    public String apply() {
      String _plus = (XtraitjValidator.PREFIX + "FieldConflict");
      return _plus;
    }
  }.apply();
  
  public final static String METHOD_CONFLICT = new Function0<String>() {
    public String apply() {
      String _plus = (XtraitjValidator.PREFIX + "MethodConflict");
      return _plus;
    }
  }.apply();
  
  public final static String MEMBER_ALREADY_EXISTS = new Function0<String>() {
    public String apply() {
      String _plus = (XtraitjValidator.PREFIX + "MemberAlreadyExists");
      return _plus;
    }
  }.apply();
  
  @Inject
  @Extension
  private TraitJJvmModelUtil _traitJJvmModelUtil;
  
  @Check
  public void checkDependencyCycle(final TJTrait t) {
    Iterable<TJTrait> _allTraitsDependency = TraitJModelUtil.allTraitsDependency(t);
    final Function1<TJTrait,Boolean> _function = new Function1<TJTrait,Boolean>() {
      public Boolean apply(final TJTrait it) {
        boolean _equals = Objects.equal(it, t);
        return Boolean.valueOf(_equals);
      }
    };
    boolean _exists = IterableExtensions.<TJTrait>exists(_allTraitsDependency, _function);
    if (_exists) {
      String _name = t.getName();
      String _plus = ("Cycle in dependency of \'" + _name);
      String _plus_1 = (_plus + "\'");
      EAttribute _tJDeclaration_Name = XtraitjPackage.eINSTANCE.getTJDeclaration_Name();
      this.error(_plus_1, _tJDeclaration_Name, 
        XtraitjValidator.DEPENDENCY_CYCLE);
    }
  }
  
  @Check
  public void checkFieldInitialization(final TJField f) {
    boolean _and = false;
    XExpression _init = f.getInit();
    boolean _notEquals = (!Objects.equal(_init, null));
    if (!_notEquals) {
      _and = false;
    } else {
      EObject _eContainer = f.eContainer();
      _and = (_notEquals && (_eContainer instanceof TJTrait));
    }
    if (_and) {
      EReference _tJField_Init = XtraitjPackage.eINSTANCE.getTJField_Init();
      this.error(
        "Traits cannot initialize fields", _tJField_Init, 
        XtraitjValidator.TRAIT_INITIALIZES_FIELD);
    }
  }
  
  @Check
  public void checkClassProvidesAllRequirements(final TJClass c) {
    Iterable<JvmOperation> _jvmAllRequiredFieldOperations = this._traitJJvmModelUtil.jvmAllRequiredFieldOperations(c);
    final Procedure1<JvmOperation> _function = new Procedure1<JvmOperation>() {
      public void apply(final JvmOperation requiredField) {
        EList<TJField> _fields = c.getFields();
        TJField _findMatchingField = XtraitjValidator.this._traitJJvmModelUtil.findMatchingField(_fields, requiredField);
        boolean _equals = Objects.equal(_findMatchingField, null);
        if (_equals) {
          String _fieldRepresentation = XtraitjValidator.this._traitJJvmModelUtil.fieldRepresentation(requiredField);
          String _plus = ("Class must provide required field \'" + _fieldRepresentation);
          String _plus_1 = (_plus + "\'");
          EReference _tJDeclaration_TraitExpression = XtraitjPackage.eINSTANCE.getTJDeclaration_TraitExpression();
          XtraitjValidator.this.error(_plus_1, _tJDeclaration_TraitExpression, 
            XtraitjValidator.MISSING_REQUIRED_FIELD);
        }
      }
    };
    IterableExtensions.<JvmOperation>forEach(_jvmAllRequiredFieldOperations, _function);
    Iterable<JvmOperation> _jvmAllRequiredMethodOperations = this._traitJJvmModelUtil.jvmAllRequiredMethodOperations(c);
    final Procedure1<JvmOperation> _function_1 = new Procedure1<JvmOperation>() {
      public void apply(final JvmOperation requiredMethod) {
        Iterable<JvmOperation> _jvmAllMethodOperations = XtraitjValidator.this._traitJJvmModelUtil.jvmAllMethodOperations(c);
        JvmOperation _findMatchingMethod = XtraitjValidator.this._traitJJvmModelUtil.findMatchingMethod(_jvmAllMethodOperations, requiredMethod);
        boolean _equals = Objects.equal(_findMatchingMethod, null);
        if (_equals) {
          String _methodRepresentation = XtraitjValidator.this._traitJJvmModelUtil.methodRepresentation(requiredMethod);
          String _plus = ("Class must provide required method \'" + _methodRepresentation);
          String _plus_1 = (_plus + "\'");
          EReference _tJDeclaration_TraitExpression = XtraitjPackage.eINSTANCE.getTJDeclaration_TraitExpression();
          XtraitjValidator.this.error(_plus_1, _tJDeclaration_TraitExpression, 
            XtraitjValidator.MISSING_REQUIRED_METHOD);
        }
      }
    };
    IterableExtensions.<JvmOperation>forEach(_jvmAllRequiredMethodOperations, _function_1);
    Iterable<JvmOperation> _jvmAllInterfaceMethods = this._traitJJvmModelUtil.jvmAllInterfaceMethods(c);
    final Procedure1<JvmOperation> _function_2 = new Procedure1<JvmOperation>() {
      public void apply(final JvmOperation method) {
        Iterable<JvmOperation> _jvmAllMethods = XtraitjValidator.this._traitJJvmModelUtil.jvmAllMethods(c);
        JvmOperation _findMatchingMethod = XtraitjValidator.this._traitJJvmModelUtil.findMatchingMethod(_jvmAllMethods, method);
        boolean _equals = Objects.equal(_findMatchingMethod, null);
        if (_equals) {
          String _methodRepresentation = XtraitjValidator.this._traitJJvmModelUtil.methodRepresentation(method);
          String _plus = ("Class must provide interface method \'" + _methodRepresentation);
          String _plus_1 = (_plus + "\'");
          EAttribute _tJDeclaration_Name = XtraitjPackage.eINSTANCE.getTJDeclaration_Name();
          XtraitjValidator.this.error(_plus_1, _tJDeclaration_Name, 
            XtraitjValidator.MISSING_INTERFACE_METHOD);
        }
      }
    };
    IterableExtensions.<JvmOperation>forEach(_jvmAllInterfaceMethods, _function_2);
  }
  
  @Check
  public void checkImplementsInterfaces(final TJClass c) {
    EList<JvmParameterizedTypeReference> _interfaces = c.getInterfaces();
    for (final JvmParameterizedTypeReference i : _interfaces) {
      boolean _isValidInterface = this._traitJJvmModelUtil.isValidInterface(i);
      boolean _not = (!_isValidInterface);
      if (_not) {
        String _simpleName = i.getSimpleName();
        String _plus = ("Not a valid interface \'" + _simpleName);
        String _plus_1 = (_plus + "\'");
        this.error(_plus_1, i, 
          null, 
          XtraitjValidator.NOT_AN_INTERFACE);
      }
    }
  }
  
  @Check
  public void checkDuplicateMembers(final TJMember m) {
    TJDeclaration _containingDeclaration = TraitJModelUtil.containingDeclaration(m);
    EList<? extends TJMember> _members = TraitJModelUtil.members(_containingDeclaration);
    final Function1<TJMember,Boolean> _function = new Function1<TJMember,Boolean>() {
      public Boolean apply(final TJMember it) {
        boolean _and = false;
        boolean _notEquals = (!Objects.equal(it, m));
        if (!_notEquals) {
          _and = false;
        } else {
          String _name = it.getName();
          String _name_1 = m.getName();
          boolean _equals = Objects.equal(_name, _name_1);
          _and = (_notEquals && _equals);
        }
        return Boolean.valueOf(_and);
      }
    };
    boolean _exists = IterableExtensions.exists(_members, _function);
    if (_exists) {
      String _name = m.getName();
      String _plus = ("Duplicate member \'" + _name);
      String _plus_1 = (_plus + "\'");
      EAttribute _tJMember_Name = XtraitjPackage.eINSTANCE.getTJMember_Name();
      this.error(_plus_1, _tJMember_Name, 
        XtraitjValidator.DUPLICATE_MEMBER);
    }
  }
  
  @Check
  public void checkDuplicateDeclaration(final TJDeclaration d) {
    TJProgram _containingProgram = TraitJModelUtil.containingProgram(d);
    EList<TJDeclaration> _elements = _containingProgram.getElements();
    final Function1<TJDeclaration,Boolean> _function = new Function1<TJDeclaration,Boolean>() {
      public Boolean apply(final TJDeclaration it) {
        boolean _and = false;
        boolean _notEquals = (!Objects.equal(it, d));
        if (!_notEquals) {
          _and = false;
        } else {
          String _name = it.getName();
          String _name_1 = d.getName();
          boolean _equals = Objects.equal(_name, _name_1);
          _and = (_notEquals && _equals);
        }
        return Boolean.valueOf(_and);
      }
    };
    boolean _exists = IterableExtensions.<TJDeclaration>exists(_elements, _function);
    if (_exists) {
      String _name = d.getName();
      String _plus = ("Duplicate declaration \'" + _name);
      String _plus_1 = (_plus + "\'");
      EAttribute _tJDeclaration_Name = XtraitjPackage.eINSTANCE.getTJDeclaration_Name();
      this.error(_plus_1, _tJDeclaration_Name, 
        XtraitjValidator.DUPLICATE_DECLARATION);
    }
  }
  
  @Check
  public void checkConflicts(final TJDeclaration d) {
    List<TJTraitReference> _traitReferences = TraitJModelUtil.traitReferences(d);
    for (final TJTraitReference t1 : _traitReferences) {
      {
        Iterable<JvmOperation> _jvmAllRequiredFieldOperations = this._traitJJvmModelUtil.jvmAllRequiredFieldOperations(t1);
        for (final JvmOperation f1 : _jvmAllRequiredFieldOperations) {
          List<TJTraitReference> _traitReferences_1 = TraitJModelUtil.traitReferences(d);
          for (final TJTraitReference t2 : _traitReferences_1) {
            boolean _notEquals = (!Objects.equal(t1, t2));
            if (_notEquals) {
              Iterable<JvmOperation> _jvmAllRequiredFieldOperations_1 = this._traitJJvmModelUtil.jvmAllRequiredFieldOperations(t2);
              final Function1<JvmOperation,Boolean> _function = new Function1<JvmOperation,Boolean>() {
                public Boolean apply(final JvmOperation it) {
                  boolean _conflictsWith = XtraitjValidator.this._traitJJvmModelUtil.conflictsWith(it, f1);
                  return Boolean.valueOf(_conflictsWith);
                }
              };
              boolean _exists = IterableExtensions.<JvmOperation>exists(_jvmAllRequiredFieldOperations_1, _function);
              if (_exists) {
                String _fieldRepresentation = this._traitJJvmModelUtil.fieldRepresentation(f1);
                String _plus = ("Field conflict \'" + _fieldRepresentation);
                String _plus_1 = (_plus + "\' in ");
                TJTrait _trait = t1.getTrait();
                String _name = _trait.getName();
                String _plus_2 = (_plus_1 + _name);
                this.error(_plus_2, t1, 
                  null, 
                  XtraitjValidator.FIELD_CONFLICT);
              }
            }
          }
        }
        Iterable<JvmOperation> _jvmAllRequiredMethodOperations = this._traitJJvmModelUtil.jvmAllRequiredMethodOperations(t1);
        for (final JvmOperation f1_1 : _jvmAllRequiredMethodOperations) {
          List<TJTraitReference> _traitReferences_2 = TraitJModelUtil.traitReferences(d);
          for (final TJTraitReference t2_1 : _traitReferences_2) {
            boolean _notEquals_1 = (!Objects.equal(t1, t2_1));
            if (_notEquals_1) {
              Iterable<JvmOperation> _jvmAllRequiredMethodOperations_1 = this._traitJJvmModelUtil.jvmAllRequiredMethodOperations(t2_1);
              final Function1<JvmOperation,Boolean> _function_1 = new Function1<JvmOperation,Boolean>() {
                public Boolean apply(final JvmOperation it) {
                  boolean _conflictsWith = XtraitjValidator.this._traitJJvmModelUtil.conflictsWith(it, f1_1);
                  return Boolean.valueOf(_conflictsWith);
                }
              };
              boolean _exists_1 = IterableExtensions.<JvmOperation>exists(_jvmAllRequiredMethodOperations_1, _function_1);
              if (_exists_1) {
                String _methodRepresentation = this._traitJJvmModelUtil.methodRepresentation(f1_1);
                String _plus_3 = ("Method conflict \'" + _methodRepresentation);
                String _plus_4 = (_plus_3 + "\' in ");
                TJTrait _trait_1 = t1.getTrait();
                String _name_1 = _trait_1.getName();
                String _plus_5 = (_plus_4 + _name_1);
                this.error(_plus_5, t1, 
                  null, 
                  XtraitjValidator.METHOD_CONFLICT);
              }
            }
          }
        }
        Iterable<JvmOperation> _jvmAllMethodOperations = this._traitJJvmModelUtil.jvmAllMethodOperations(t1);
        for (final JvmOperation f1_2 : _jvmAllMethodOperations) {
          List<TJTraitReference> _traitReferences_3 = TraitJModelUtil.traitReferences(d);
          for (final TJTraitReference t2_2 : _traitReferences_3) {
            boolean _notEquals_2 = (!Objects.equal(t1, t2_2));
            if (_notEquals_2) {
              Iterable<JvmOperation> _jvmAllMethodOperations_1 = this._traitJJvmModelUtil.jvmAllMethodOperations(t2_2);
              final Function1<JvmOperation,Boolean> _function_2 = new Function1<JvmOperation,Boolean>() {
                public Boolean apply(final JvmOperation it) {
                  String _simpleName = f1_2.getSimpleName();
                  String _simpleName_1 = it.getSimpleName();
                  boolean _equals = Objects.equal(_simpleName, _simpleName_1);
                  return Boolean.valueOf(_equals);
                }
              };
              boolean _exists_2 = IterableExtensions.<JvmOperation>exists(_jvmAllMethodOperations_1, _function_2);
              if (_exists_2) {
                String _methodRepresentation_1 = this._traitJJvmModelUtil.methodRepresentation(f1_2);
                String _plus_6 = ("Method conflict \'" + _methodRepresentation_1);
                String _plus_7 = (_plus_6 + "\' in ");
                TJTrait _trait_2 = t1.getTrait();
                String _name_2 = _trait_2.getName();
                String _plus_8 = (_plus_7 + _name_2);
                this.error(_plus_8, t1, 
                  null, 
                  XtraitjValidator.METHOD_CONFLICT);
              }
            }
          }
        }
      }
    }
  }
  
  @Check
  public void checkConflicts(final TJField f) {
    TJTrait _containingTrait = TraitJModelUtil.containingTrait(f);
    boolean _equals = Objects.equal(_containingTrait, null);
    if (_equals) {
      return;
    }
    TJTrait _containingTrait_1 = TraitJModelUtil.containingTrait(f);
    List<TJTraitReference> _traitReferences = TraitJModelUtil.traitReferences(_containingTrait_1);
    for (final TJTraitReference t1 : _traitReferences) {
      {
        Iterable<JvmOperation> _jvmAllRequiredFieldOperations = this._traitJJvmModelUtil.jvmAllRequiredFieldOperations(t1);
        final Function1<JvmOperation,Boolean> _function = new Function1<JvmOperation,Boolean>() {
          public Boolean apply(final JvmOperation it) {
            String _simpleName = it.getSimpleName();
            String _stripGetter = XtraitjValidator.this._traitJJvmModelUtil.stripGetter(_simpleName);
            String _name = f.getName();
            boolean _equals = Objects.equal(_stripGetter, _name);
            return Boolean.valueOf(_equals);
          }
        };
        final JvmOperation conflict = IterableExtensions.<JvmOperation>findFirst(_jvmAllRequiredFieldOperations, _function);
        boolean _notEquals = (!Objects.equal(t1, null));
        if (_notEquals) {
          String _fieldRepresentation = this._traitJJvmModelUtil.fieldRepresentation(conflict);
          String _plus = ("Field conflict \'" + _fieldRepresentation);
          String _plus_1 = (_plus + "\' in ");
          TJTrait _trait = t1.getTrait();
          String _name = _trait.getName();
          String _plus_2 = (_plus_1 + _name);
          this.error(_plus_2, t1, 
            null, 
            XtraitjValidator.FIELD_CONFLICT);
          String _name_1 = f.getName();
          String _plus_3 = ("Field conflict \'" + _name_1);
          String _plus_4 = (_plus_3 + "\'");
          EAttribute _tJMember_Name = XtraitjPackage.eINSTANCE.getTJMember_Name();
          this.error(_plus_4, _tJMember_Name, 
            XtraitjValidator.FIELD_CONFLICT);
        }
      }
    }
  }
  
  @Check
  public void checkConflicts(final TJRequiredMethod m) {
    TJTrait _containingTrait = TraitJModelUtil.containingTrait(m);
    boolean _equals = Objects.equal(_containingTrait, null);
    if (_equals) {
      return;
    }
    TJTrait _containingTrait_1 = TraitJModelUtil.containingTrait(m);
    List<TJTraitReference> _traitReferences = TraitJModelUtil.traitReferences(_containingTrait_1);
    for (final TJTraitReference t1 : _traitReferences) {
      {
        Iterable<JvmOperation> _jvmAllOperations = this._traitJJvmModelUtil.jvmAllOperations(t1);
        final Function1<JvmOperation,Boolean> _function = new Function1<JvmOperation,Boolean>() {
          public Boolean apply(final JvmOperation it) {
            String _simpleName = it.getSimpleName();
            String _name = m.getName();
            boolean _equals = Objects.equal(_simpleName, _name);
            return Boolean.valueOf(_equals);
          }
        };
        final JvmOperation conflict = IterableExtensions.<JvmOperation>findFirst(_jvmAllOperations, _function);
        boolean _notEquals = (!Objects.equal(t1, null));
        if (_notEquals) {
          String _methodRepresentation = this._traitJJvmModelUtil.methodRepresentation(conflict);
          String _plus = ("Method conflict \'" + _methodRepresentation);
          String _plus_1 = (_plus + "\' in ");
          TJTrait _trait = t1.getTrait();
          String _name = _trait.getName();
          String _plus_2 = (_plus_1 + _name);
          this.error(_plus_2, t1, 
            null, 
            XtraitjValidator.METHOD_CONFLICT);
          String _name_1 = m.getName();
          String _plus_3 = ("Method conflict \'" + _name_1);
          String _plus_4 = (_plus_3 + "\'");
          EAttribute _tJMember_Name = XtraitjPackage.eINSTANCE.getTJMember_Name();
          this.error(_plus_4, _tJMember_Name, 
            XtraitjValidator.METHOD_CONFLICT);
        }
      }
    }
  }
  
  @Check
  public void checkConflicts(final TJMethod m) {
    TJTrait _containingTrait = TraitJModelUtil.containingTrait(m);
    boolean _equals = Objects.equal(_containingTrait, null);
    if (_equals) {
      return;
    }
    TJTrait _containingTrait_1 = TraitJModelUtil.containingTrait(m);
    List<TJTraitReference> _traitReferences = TraitJModelUtil.traitReferences(_containingTrait_1);
    for (final TJTraitReference t1 : _traitReferences) {
      {
        Iterable<JvmOperation> _jvmAllMethodOperations = this._traitJJvmModelUtil.jvmAllMethodOperations(t1);
        final Function1<JvmOperation,Boolean> _function = new Function1<JvmOperation,Boolean>() {
          public Boolean apply(final JvmOperation it) {
            String _simpleName = it.getSimpleName();
            String _name = m.getName();
            boolean _equals = Objects.equal(_simpleName, _name);
            return Boolean.valueOf(_equals);
          }
        };
        final JvmOperation conflict = IterableExtensions.<JvmOperation>findFirst(_jvmAllMethodOperations, _function);
        boolean _notEquals = (!Objects.equal(t1, null));
        if (_notEquals) {
          String _methodRepresentation = this._traitJJvmModelUtil.methodRepresentation(conflict);
          String _plus = ("Method conflict \'" + _methodRepresentation);
          String _plus_1 = (_plus + "\' in ");
          TJTrait _trait = t1.getTrait();
          String _name = _trait.getName();
          String _plus_2 = (_plus_1 + _name);
          this.error(_plus_2, t1, 
            null, 
            XtraitjValidator.METHOD_CONFLICT);
          String _name_1 = m.getName();
          String _plus_3 = ("Method conflict \'" + _name_1);
          String _plus_4 = (_plus_3 + "\'");
          EAttribute _tJMember_Name = XtraitjPackage.eINSTANCE.getTJMember_Name();
          this.error(_plus_4, _tJMember_Name, 
            XtraitjValidator.METHOD_CONFLICT);
        }
      }
    }
  }
  
  /**
   * Check that there are no duplicate trait references (without
   * operations) to the same trait (which would be useless and
   * would cause Java compiler errors).
   */
  @Check
  public void checkDuplicateTraitReference(final TJClass c) {
    TJTraitExpression _traitExpression = c.getTraitExpression();
    List<TJTraitReference> _traitReferences = TraitJModelUtil.traitReferences(_traitExpression);
    final Function1<TJTraitReference,Boolean> _function = new Function1<TJTraitReference,Boolean>() {
      public Boolean apply(final TJTraitReference it) {
        EList<TJTraitOperation> _operations = it.getOperations();
        boolean _isEmpty = _operations.isEmpty();
        return Boolean.valueOf(_isEmpty);
      }
    };
    final Iterable<TJTraitReference> referencesWithNoOperations = IterableExtensions.<TJTraitReference>filter(_traitReferences, _function);
    for (final TJTraitReference ref : referencesWithNoOperations) {
      final Function1<TJTraitReference,Boolean> _function_1 = new Function1<TJTraitReference,Boolean>() {
        public Boolean apply(final TJTraitReference it) {
          boolean _and = false;
          boolean _notEquals = (!Objects.equal(ref, it));
          if (!_notEquals) {
            _and = false;
          } else {
            TJTrait _trait = ref.getTrait();
            TJTrait _trait_1 = it.getTrait();
            boolean _equals = Objects.equal(_trait, _trait_1);
            _and = (_notEquals && _equals);
          }
          return Boolean.valueOf(_and);
        }
      };
      TJTraitReference _findFirst = IterableExtensions.<TJTraitReference>findFirst(referencesWithNoOperations, _function_1);
      boolean _notEquals = (!Objects.equal(_findFirst, null));
      if (_notEquals) {
        TJTrait _trait = ref.getTrait();
        String _name = _trait.getName();
        String _plus = ("Duplicate trait reference \'" + _name);
        String _plus_1 = (_plus + "\'");
        this.error(_plus_1, ref, 
          null, 
          XtraitjValidator.DUPLICATE_TRAIT_REFERENCE);
      }
    }
  }
  
  @Check
  public void checkTraitHideOperation(final TJHideOperation op) {
    this.errorForRequiredMember(op, "hide", XtraitjValidator.HIDING_REQUIRED);
  }
  
  @Check
  public void checkTraitAliasOperation(final TJAliasOperation op) {
    this.errorForRequiredMember(op, "alias", XtraitjValidator.ALIASING_REQUIRED);
    String _newname = op.getNewname();
    EAttribute _tJAliasOperation_Newname = XtraitjPackage.eINSTANCE.getTJAliasOperation_Newname();
    this.errorForAlterationToExistingMember(op, _newname, _tJAliasOperation_Newname);
  }
  
  @Check
  public void checkTraitRenameOperation(final TJRenameOperation op) {
    String _newname = op.getNewname();
    EAttribute _tJRenameOperation_Newname = XtraitjPackage.eINSTANCE.getTJRenameOperation_Newname();
    this.errorForAlterationToExistingMember(op, _newname, _tJRenameOperation_Newname);
  }
  
  @Check
  public void checkTraitRestrictOperation(final TJRestrictOperation op) {
    this.errorForRequiredMember(op, "restrict", XtraitjValidator.RESTRICTING_REQUIRED);
  }
  
  private void errorForRequiredMember(final TjTraitOperationForProvided op, final String opName, final String issue) {
    final JvmMember member = op.getMember();
    boolean _and = false;
    boolean _notEquals = (!Objects.equal(member, null));
    if (!_notEquals) {
      _and = false;
    } else {
      boolean _isRequired = this._traitJJvmModelUtil.isRequired(member);
      _and = (_notEquals && _isRequired);
    }
    if (_and) {
      String _plus = ("Cannot " + opName);
      String _plus_1 = (_plus + " required method \'");
      String _simpleName = member.getSimpleName();
      String _plus_2 = (_plus_1 + _simpleName);
      String _plus_3 = (_plus_2 + "\'");
      EReference _tJTraitOperation_Member = XtraitjPackage.eINSTANCE.getTJTraitOperation_Member();
      this.error(_plus_3, _tJTraitOperation_Member, issue);
    }
  }
  
  private void errorForAlterationToExistingMember(final TJTraitOperation op, final String newname, final EStructuralFeature feature) {
    TJTraitReference _containingTraitOperationExpression = TraitJModelUtil.containingTraitOperationExpression(op);
    TJTrait _trait = _containingTraitOperationExpression.getTrait();
    EList<TJMember> _members = _trait.getMembers();
    final Function1<TJMember,Boolean> _function = new Function1<TJMember,Boolean>() {
      public Boolean apply(final TJMember it) {
        String _name = it.getName();
        boolean _equals = Objects.equal(_name, newname);
        return Boolean.valueOf(_equals);
      }
    };
    boolean _exists = IterableExtensions.<TJMember>exists(_members, _function);
    if (_exists) {
      String _plus = ("Member already exists \'" + newname);
      String _plus_1 = (_plus + "\'");
      this.error(_plus_1, feature, 
        XtraitjValidator.MEMBER_ALREADY_EXISTS);
    }
  }
  
  @Check
  public void checkRedirect(final TJRedirectOperation op) {
    boolean _and = false;
    JvmMember _member = op.getMember();
    boolean _notEquals = (!Objects.equal(_member, null));
    if (!_notEquals) {
      _and = false;
    } else {
      JvmMember _member2 = op.getMember2();
      boolean _notEquals_1 = (!Objects.equal(_member2, null));
      _and = (_notEquals && _notEquals_1);
    }
    if (_and) {
      JvmMember _member_1 = op.getMember();
      final TJMember sourceMember = this._traitJJvmModelUtil.originalSource(_member_1);
      JvmMember _member2_1 = op.getMember2();
      final TJMember sourceMember2 = this._traitJJvmModelUtil.originalSource(_member2_1);
      JvmMember _member_2 = op.getMember();
      JvmMember _member2_2 = op.getMember2();
      boolean _equals = Objects.equal(_member_2, _member2_2);
      if (_equals) {
        String _name = sourceMember.getName();
        String _plus = ("Redirect to the same member \'" + _name);
        String _plus_1 = (_plus + "\'");
        EReference _tJRedirectOperation_Member2 = XtraitjPackage.eINSTANCE.getTJRedirectOperation_Member2();
        this.error(_plus_1, _tJRedirectOperation_Member2, 
          XtraitjValidator.REDIRECT_TO_SAME_MEMBER);
      } else {
        boolean _and_1 = false;
        if (!(sourceMember instanceof TJField)) {
          _and_1 = false;
        } else {
          _and_1 = ((sourceMember instanceof TJField) && (sourceMember2 instanceof TJMethodDeclaration));
        }
        if (_and_1) {
          String _name_1 = sourceMember.getName();
          String _plus_2 = ("Cannot redirect field \'" + _name_1);
          String _plus_3 = (_plus_2 + "\'");
          String _plus_4 = (_plus_3 + " to method \'");
          String _name_2 = sourceMember2.getName();
          String _plus_5 = (_plus_4 + _name_2);
          String _plus_6 = (_plus_5 + "\'");
          EReference _tJRedirectOperation_Member2_1 = XtraitjPackage.eINSTANCE.getTJRedirectOperation_Member2();
          this.error(_plus_6, _tJRedirectOperation_Member2_1, 
            XtraitjValidator.FIELD_REDIRECTED_TO_METHOD);
        } else {
          boolean _and_2 = false;
          if (!(sourceMember instanceof TJMethodDeclaration)) {
            _and_2 = false;
          } else {
            _and_2 = ((sourceMember instanceof TJMethodDeclaration) && (sourceMember2 instanceof TJField));
          }
          if (_and_2) {
            String _name_3 = sourceMember.getName();
            String _plus_7 = ("Cannot redirect method \'" + _name_3);
            String _plus_8 = (_plus_7 + "\'");
            String _plus_9 = (_plus_8 + " to field \'");
            String _name_4 = sourceMember2.getName();
            String _plus_10 = (_plus_9 + _name_4);
            String _plus_11 = (_plus_10 + "\'");
            EReference _tJRedirectOperation_Member2_2 = XtraitjPackage.eINSTANCE.getTJRedirectOperation_Member2();
            this.error(_plus_11, _tJRedirectOperation_Member2_2, 
              XtraitjValidator.METHOD_REDIRECTED_TO_FIELD);
          } else {
            JvmMember _member2_3 = op.getMember2();
            JvmMember _member_3 = op.getMember();
            boolean _compliant = this._traitJJvmModelUtil.compliant(_member2_3, _member_3);
            boolean _not = (!_compliant);
            if (_not) {
              JvmMember _member2_4 = op.getMember2();
              String _memberRepresentation = this._traitJJvmModelUtil.memberRepresentation(_member2_4);
              String _plus_12 = ("\'" + _memberRepresentation);
              String _plus_13 = (_plus_12 + "\'");
              String _plus_14 = (_plus_13 + 
                " is not compliant with \'");
              JvmMember _member_4 = op.getMember();
              String _memberRepresentation_1 = this._traitJJvmModelUtil.memberRepresentation(_member_4);
              String _plus_15 = (_plus_14 + _memberRepresentation_1);
              String _plus_16 = (_plus_15 + "\'");
              EReference _tJRedirectOperation_Member2_3 = XtraitjPackage.eINSTANCE.getTJRedirectOperation_Member2();
              this.error(_plus_16, _tJRedirectOperation_Member2_3, 
                XtraitjValidator.REDIRECT_NOT_COMPLIANT);
            }
          }
        }
      }
    }
  }
}
